---
phase: 03-backup-data-integrity
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - package.json
  - utils/backup-schema.ts
  - utils/backup.ts
autonomous: true

must_haves:
  truths:
    - "Invalid backup import shows validation error instead of corrupting IndexedDB"
    - "Valid backup passes schema check before any DB write"
  artifacts:
    - path: utils/backup-schema.ts
      provides: "Zod BackupDataSchema for runtime validation"
      contains: "BackupDataSchema"
    - path: utils/backup.ts
      provides: "importBackupData validates before clear/bulkAdd; returns error on failure"
  key_links:
    - from: utils/backup.ts
      to: utils/backup-schema.ts
      via: "BackupDataSchema.safeParse before DB operations"
      pattern: "safeParse"
---

<objective>
Add schema validation on backup import to reject invalid data before touching IndexedDB (BKUP-02).

Purpose: importBackupData currently uses `JSON.parse(text) as BackupData` with no validation. Malformed or adversarial JSON corrupts IndexedDB. Per RESEARCH: use Zod safeParse, validate before any clear/bulkAdd, return error message for UI to display.
Output: backup-schema.ts with Zod schema; import validates first, rejects invalid data with error message.
</objective>

<execution_context>
@/home/whj/.claude/get-shit-done/workflows/execute-plan.md
@/home/whj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-backup-data-integrity/03-RESEARCH.md
@utils/backup.ts
@types/db.ts
@types/common.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Zod and create backup-schema.ts</name>
  <files>package.json, utils/backup-schema.ts</files>
  <action>
1. Run `npm install zod`
2. Create utils/backup-schema.ts with Zod schema matching GridItemRecord structure. Use RESEARCH code example:
   - SiteItemRecordSchema: type='site', id, title, url, icon, pid, createdAt, updatedAt (all required; url optionally refine to http/https per PLCY-02)
   - FolderItemRecordSchema: type='folder', id, title, size (enum), createdAt, updatedAt
   - GridItemRecordSchema: z.discriminatedUnion('type', [SiteItemRecordSchema, FolderItemRecordSchema])
   - BackupDataSchema: gridItems array of GridItemRecordSchema, gridOrder optional array of strings

Use .passthrough() or allow extra keys to avoid rejecting valid legacy backups (RESEARCH Pitfall 4). Do NOT use .strict(). Export BackupDataSchema.
  </action>
  <verify>
- zod in package.json dependencies
- utils/backup-schema.ts exists; BackupDataSchema.safeParse({ gridItems: [], gridOrder: [] }) succeeds
- BackupDataSchema.safeParse({ gridItems: [{ type: 'site', id: 'x', title: 't', url: 'https://x.com', icon: '', pid: null, createdAt: 0, updatedAt: 0 }] }) succeeds
- BackupDataSchema.safeParse({}) fails (gridItems required)
- BackupDataSchema.safeParse({ gridItems: [{ type: 'invalid' }] }) fails
  </verify>
  <done>Zod installed; BackupDataSchema validates backup shape; backward compat for missing gridOrder</done>
</task>

<task type="auto">
  <name>Task 2: Add validation to importBackupData before DB write</name>
  <files>utils/backup.ts</files>
  <action>
In importBackupData, replace type assertion with Zod validation. Change return type to `Promise<{ success: true } | { success: false; error: string }>` so callers can display validation errors:

1. After JSON.parse in try block, store result as `parsed: unknown` (not BackupData)
2. Call `const result = BackupDataSchema.safeParse(parsed)`
3. If `!result.success`: return `{ success: false, error: result.error.message }` (or formatted message), log `[备份]: 数据格式无效`
4. If result.success: use `result.data` for validated data; proceed with existing logic (clear, bulkAdd, updateGridOrder, loadGridItems)
5. On success: return `{ success: true }`
6. On DB/other error: return `{ success: false, error: '导入失败' }` (or actual error message)

Do NOT clear or bulkAdd until schema passes. Remove `as BackupData`—never use type assertion for user input.
  </action>
  <verify>
- Invalid JSON (malformed): returns { success: false, error: ... } (JSON.parse fails first—keep existing try/catch)
- Valid JSON with wrong shape (e.g. gridItems: "not-array"): returns { success: false, error: ... }; IndexedDB unchanged
- Valid backup: returns { success: true }; data restored
- npm run build succeeds
  </verify>
  <done>Import validates before write; invalid data returns error object; IndexedDB protected from corruption</done>
</task>

</tasks>

<verification>
- Invalid backup file triggers validation error, no DB write
- Valid backup imports successfully
- Caller can access error message for UI display
</verification>

<success_criteria>
BKUP-02 satisfied: Invalid backup import shows validation error instead of corrupting IndexedDB
</success_criteria>

<output>
After completion, create `.planning/phases/03-backup-data-integrity/03-02-SUMMARY.md`
</output>
